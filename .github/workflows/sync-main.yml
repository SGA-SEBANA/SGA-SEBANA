name: Auto-update developer branches from main

on:
  push:
    branches:
      - main

jobs:
  update-branches:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get branches with open PRs
        id: get-active-prs
        uses: actions/github-script@v7
        with:
          script: |
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            const prBranches = prs.data.map(pr => pr.head.ref);
            core.setOutput('pr_branches', prBranches.join(','));
            console.log('Branches with open PRs:', prBranches);

      - name: Get developer branches
        id: get-branches
        run: |
          echo "Fetching all branches..."
          git fetch --all
          PR_BRANCHES="${{ steps.get-active-prs.outputs.pr_branches }}"
          all_branches="julian-clot derlis-hernandez joel-peralta jorge-castrillo"
          filtered_branches=""
          for branch in $all_branches; do
            skip=false
            IFS=',' read -ra PR_BRANCH_ARRAY <<< "$PR_BRANCHES"
            for pr_branch in "${PR_BRANCH_ARRAY[@]}"; do
              if [ "$branch" == "$pr_branch" ]; then
                skip=true
                echo "‚è≠Ô∏è  Skipping $branch (has open PR)"
                break
              fi
            done
            if [ "$skip" = false ]; then
              filtered_branches="$filtered_branches $branch"
            fi
          done
          echo "branches=$filtered_branches" >> $GITHUB_OUTPUT
          echo "Branches to update:$filtered_branches"

      - name: Update each branch
        continue-on-error: true
        run: |
          branches="${{ steps.get-branches.outputs.branches }}"
          if [ -z "$branches" ]; then
            echo "No branches to update"
            exit 0
          fi
          for branch in $branches; do
            echo "========================================="
            echo "Processing branch: $branch"
            echo "========================================="
            if ! git fetch origin $branch; then
              echo "‚ùå Could not fetch $branch"
              echo "$branch|fetch-failed|Could not fetch branch" >> /tmp/branch-status.txt
              continue
            fi
            STATUS="success"
            ERROR_MSG=""
            if git checkout $branch 2>/dev/null; then
              echo "‚úì Checked out $branch"
              BEHIND=$(git rev-list --count HEAD..origin/main)
              echo "Branch is $BEHIND commits behind main"
              if [ "$BEHIND" -eq 0 ]; then
                echo "‚è≠Ô∏è  Branch is already up to date"
                STATUS="up-to-date"
              else
                if git rebase origin/main; then
                  echo "‚úì Rebase successful for $branch"
                  max_retries=3
                  retry_count=0
                  push_success=false
                  while [ $retry_count -lt $max_retries ]; do
                    if git push origin $branch --force-with-lease; then
                      echo "‚úÖ Successfully updated $branch"
                      push_success=true
                      break
                    else
                      retry_count=$((retry_count + 1))
                      echo "‚ö†Ô∏è  Push attempt $retry_count failed, retrying..."
                      sleep 2
                    fi
                  done
                  if [ "$push_success" = false ]; then
                    STATUS="push-failed"
                    ERROR_MSG="Failed to push after $max_retries attempts"
                    echo "‚ùå Push failed for $branch after retries"
                  fi
                else
                  STATUS="conflict"
                  ERROR_MSG="Rebase conflict detected"
                  echo "‚ùå Rebase conflict on $branch"
                  git rebase --abort
                fi
              fi
            else
              STATUS="checkout-failed"
              ERROR_MSG="Failed to checkout branch"
              echo "‚ùå Could not checkout $branch"
            fi
            git checkout main 2>/dev/null || true
            echo "$branch|$STATUS|$ERROR_MSG" >> /tmp/branch-status.txt
            echo ""
          done

      - name: Create or update issues for conflicts
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const branchToUser = {
              'julian-clot': 'JulianClotCordoba',
              'derlis-hernandez': 'derlisbach-lang',
              'joel-peralta': 'joeljperalta',
              'jorge-castrillo': 'JorgeLuisCastrilloMolina'
            };
            if (!fs.existsSync('/tmp/branch-status.txt')) {
              console.log('No status file found');
              return;
            }
            const statusFile = fs.readFileSync('/tmp/branch-status.txt', 'utf8');
            const lines = statusFile.trim().split('\n').filter(l => l);
            for (const line of lines) {
              const [branch, status, errorMsg] = line.split('|');
              if (status === 'conflict') {
                const title = `üî• Conflicto en branch: ${branch} al actualizar desde main`;
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                  labels: "auto-update-conflict"
                });
                const existing = issues.data.find(i => 
                  i.title.includes(branch) && i.labels.some(l => l.name === "auto-update-conflict")
                );
                if (!existing) {
                  const username = branchToUser[branch] || branch;
                  const issueBody = `
            ### ‚ö†Ô∏è Conflicto detectado al actualizar desde \`main\`

            El branch \`${branch}\` tiene conflictos con la versi√≥n actual de \`main\` y no pudo ser actualizado autom√°ticamente.

            **Commit que caus√≥ el conflicto:** [\`${context.sha.substring(0, 7)}\`](${context.payload.repository.html_url}/commit/${context.sha})
            **Mensaje:** ${context.payload.head_commit.message}
            **Fecha:** ${new Date().toISOString()}

            ---

            ### üîß C√≥mo resolver:

            \`\`\`bash
            # 1. Actualiza tu branch local
            git checkout ${branch}
            git fetch origin

            # 2. Intenta hacer rebase con main
            git rebase origin/main

            # 3. Resuelve los conflictos en los archivos marcados
            # Los archivos con conflictos aparecer√°n con <<<<<<< y >>>>>>>

            # 4. Despu√©s de resolver cada archivo:
            git add <archivo-resuelto>

            # 5. Contin√∫a el rebase
            git rebase --continue

            # 6. Push de tus cambios (forzado, pero seguro)
            git push origin ${branch} --force-with-lease
            \`\`\`

            ---

            ### ‚ùå **NO hagas esto:**
            - ‚ùå \`git pull origin main\` (crea merge commits innecesarios)
            - ‚ùå \`git merge main\` (queremos mantener un historial limpio)
            - ‚ùå \`git push --force\` (usa \`--force-with-lease\` en su lugar)

            ---

            **Este issue se cerrar√° autom√°ticamente cuando el branch sea actualizado exitosamente.**
            `;
                  try {
                    await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: title,
                      body: issueBody,
                      assignees: [username],
                      labels: ["auto-update-conflict", "urgent", "needs-resolution"]
                    });
                    console.log(`‚úì Created issue for ${branch}, assigned to ${username}`);
                  } catch (error) {
                    console.log(`‚ö†Ô∏è  Could not assign to ${username}, creating issue without assignee`);
                    await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: title,
                      body: issueBody,
                      labels: ["auto-update-conflict", "urgent", "needs-resolution"]
                    });
                  }
                }
              } else if (status === 'success') {
                const issues = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                  labels: "auto-update-conflict"
                });
                const existing = issues.data.find(i => i.title.includes(branch));
                if (existing) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existing.number,
                    state: "closed",
                    state_reason: "completed"
                  });
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existing.number,
                    body: `‚úÖ Branch actualizado exitosamente con [\`${context.sha.substring(0, 7)}\`](${context.payload.repository.html_url}/commit/${context.sha}). Issue cerrado autom√°ticamente.`
                  });
                  console.log(`‚úì Closed issue for ${branch}`);
                }
              }
            }

      - name: Create job summary
        if: always()
        run: |
          echo "# üîÑ Auto-update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          COMMIT_MSG=$(cat <<'EOF'
          ${{ github.event.head_commit.message }}
          EOF
          )
          COMMIT_MSG_FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)
          AUTHOR_NAME=$(cat <<'EOF'
          ${{ github.event.head_commit.author.name }}
          EOF
          )
          echo "**Triggered by:** $COMMIT_MSG_FIRST_LINE" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** [\`${GITHUB_SHA:0:7}\`](${{ github.event.repository.html_url }}/commit/${GITHUB_SHA})" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** $AUTHOR_NAME" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f /tmp/branch-status.txt ]; then
            echo "## üìä Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Branch | Status | Details |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            success_count=0
            conflict_count=0
            skip_count=0
            error_count=0
            while IFS='|' read -r branch status error; do
              case $status in
                success)
                  echo "| \`$branch\` | ‚úÖ Updated | Rebased and pushed successfully |" >> $GITHUB_STEP_SUMMARY
                  success_count=$((success_count + 1))
                  ;;
                conflict)
                  echo "| \`$branch\` | ‚ùå Conflict | Issue created for resolution |" >> $GITHUB_STEP_SUMMARY
                  conflict_count=$((conflict_count + 1))
                  ;;
                up-to-date)
                  echo "| \`$branch\` | ‚è≠Ô∏è Skipped | Already up to date |" >> $GITHUB_STEP_SUMMARY
                  skip_count=$((skip_count + 1))
                  ;;
                *)
                  echo "| \`$branch\` | ‚ö†Ô∏è Error | $error |" >> $GITHUB_STEP_SUMMARY
                  error_count=$((error_count + 1))
                  ;;
              esac
            done < /tmp/branch-status.txt
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Successfully updated: **$success_count**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå Conflicts detected: **$conflict_count**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚è≠Ô∏è Already up to date: **$skip_count**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ö†Ô∏è Errors: **$error_count**" >> $GITHUB_STEP_SUMMARY
          else
            echo "No branches were processed." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Summary console output
        if: always()
        run: |
          echo "========================================="
          echo "RESUMEN DE ACTUALIZACIONES"
          echo "========================================="
          if [ -f /tmp/branch-status.txt ]; then
            while IFS='|' read -r branch status error; do
              case $status in
                success)
                  echo "‚úÖ $branch - Actualizado exitosamente"
                  ;;
                conflict)
                  echo "‚ùå $branch - Conflicto detectado (issue creado)"
                  ;;
                up-to-date)
                  echo "‚è≠Ô∏è  $branch - Ya estaba actualizado"
                  ;;
                push-failed)
                  echo "‚ö†Ô∏è  $branch - Fall√≥ el push: $error"
                  ;;
                checkout-failed)
                  echo "‚ö†Ô∏è  $branch - No se pudo hacer checkout: $error"
                  ;;
                fetch-failed)
                  echo "‚ö†Ô∏è  $branch - No se pudo hacer fetch: $error"
                  ;;
              esac
            done < /tmp/branch-status.txt
          else
            echo "No se encontraron branches para actualizar"
          fi
          echo "========================================="
